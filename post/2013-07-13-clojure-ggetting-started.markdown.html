<html lang="en"><head><meta charset="UTF-8" /><meta content="width=device-width, initial-scale=1" name="viewport" /><link href="/css/reset.css" rel="stylesheet" /><link href="/css/highlightjs/github.css" rel="stylesheet" /><script src="/js/highlight.pack.js" type="text/javascript"></script><link href="/css/styles.css" rel="stylesheet" /><link href="/css/tablets.css" rel="stylesheet" /><link href="/css/blog-post.css" rel="stylesheet" /><style>@import url('https://fonts.googleapis.com/css?family=Open+Sans:400,400i|Quattrocento&display=swap');</style><style>@import url('https://fonts.googleapis.com/css?family=Open+Sans:300&display=swap');</style><title>Clojure getting started: setting up - Mein(un)sin</title></head><body class="body"><div id="page"><header class="website-header"><h1 class="website-title"><a href="/">Mein(un)sin</a></h1><span class="website-subtitle">my (non) sense</span></header><div class="left-sidebar"><h2>All posts</h2><div id="page-index"><ul><li><a href="/post/2020-11-16-writting-clojure-cli-tools-with-joker.markdown.html">Writing Clojure cli tools with joker</a><span class="article-date">2020-11-16</span></li><li><a href="/post/2019-03-26-github-pull-request-template-example.md.html">A github pull request template example</a><span class="article-date">2019-03-26</span></li><li><a href="/post/2014-12-05-versioning-work-notes-with-git-on-mac.markdown.html">Versioning work notes with git on mac</a><span class="article-date">2014-12-5</span></li><li><a href="/post/2014-12-21-deploying-clojure-apps-on-giant-swarm-docker.markdown.html">Deploying clojure apps on giant swarm (docker)</a><span class="article-date">2014-12-21</span></li><li><a href="/post/2014-01-26-moving-to-london-banks-and-money.markdown.html">Moving to London: Banks and Money</a><span class="article-date">2014-1-26</span></li><li><a href="/post/2014-05-17-developers-love-bacon-conference.markdown.html">Developers Love Bacon - conference</a><span class="article-date">2014-05-17</span></li><li><a href="/post/2013-07-04-clojure-lesson-learned.markdown.html">Clojure lesson learned</a><span class="article-date">2013-9-27</span></li><li><a href="/post/2013-07-13-clojure-ggetting-started.markdown.html">Clojure getting started: setting up</a><span class="article-date">2013-7-17</span></li><li><a href="/post/2013-04-29-moving-the-counter-into-the-foreach-loop.markdown.html">Moving the counter into the foreach loop</a><span class="article-date">2013-4-29</span></li><li><a href="/post/2013-04-29-hello-world.markdown.html">Hello world, again</a><span class="article-date">2013-4-29</span></li><li><a href="/post/2020-11-23-dev-setup-2020.markdown.html">Dev setup 2020</a><span class="article-date"></span></li></ul></div></div><div id="blog-post"><article><div><header><h1>Clojure getting started: setting up</h1><p><time class="article-date" date="2013-7-17">2013-07-17</time> </p></header><h2>Setting Up a Project</h2><p>Clojure runs on the JVM so you need a recent  <aside class="link-aside"><div class="link-aside--title">JDK</div><div class="link-aside--url"><a class="link-aside--url--link" href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a></div></aside><a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">JDK</a>  version installed (Java 6 or newer should do).</p><p>To create a new Clojure project we use <aside class="link-aside"><div class="link-aside--title">Leiningen</div><div class="link-aside--url"><a class="link-aside--url--link" href="https://github.com/technomancy/leiningen" target="_blank">https://github.com/technomancy/leiningen</a></div></aside><a href="https://github.com/technomancy/leiningen">Leiningen</a>. On Mac OS it's just a</p><pre><code>brew install leiningen
</code></pre><p>away.</p><p>This will install Leiningen 2. Version 2 breaks compatibility with the old plugin system, but most projects that supply Leiningen have a description how to add them to your project.clj for each version. However if you start a new project, always go with Leiningen 2.</p><p>To create our getting started project (we will name it greenfield-clojure) run:</p><pre><code>lein new greenfield-clojure
</code></pre><p>This will create a new folder. For the rest of this writing all file paths will be relative to this folder.</p><p>You should see a <code>project.clj</code> file looking something like this</p><pre><code class="clojure">(defproject greenfield-clojure "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "Eclipse Public License"
            :url "http://www.eclipse.org/legal/epl-v10.html"}
  :dependencies [[org.clojure/clojure "1.5.1"]])
</code></pre><p>As you can see Clojure itself is defined as a dependency. As of this writing the latest version is 1.5.1 .</p><p>Now run</p><pre><code class="bash">lein deps
</code></pre><p>which will download and install all specified dependencies.</p><p>During this project we will add additional dependencies to this project. <aside class="link-aside"><div class="link-aside--title">CloJars</div><div class="link-aside--url"><a class="link-aside--url--link" href="https://clojars.org/clj-http" target="_blank">https://clojars.org/clj-http</a></div></aside><a href="https://clojars.org/clj-http">CloJars</a> is a repository for Clojure libaries. There you can find a lot of interesting stuff. You can also include Java dependencies from <aside class="link-aside"><div class="link-aside--title">Maven Central</div><div class="link-aside--url"><a class="link-aside--url--link" href="http://search.maven.org/" target="_blank">http://search.maven.org/</a></div></aside><a href="http://search.maven.org/">Maven Central</a>. Please consult the Leiningen <aside class="link-aside"><div class="link-aside--title">sample.project.clj</div><div class="link-aside--url"><a class="link-aside--url--link" href="https://github.com/technomancy/leiningen/blob/stable/sample.project.clj" target="_blank">https://github.com/technomancy/leiningen/blob/stable/sample.project.clj</a></div></aside><a href="https://github.com/technomancy/leiningen/blob/stable/sample.project.clj">sample.project.clj</a> for further information.</p><p><!--– more –--></p><h2>The REPL</h2><p>The REPL is a interactive environment where you can run Clojure code, in the context of your project.</p><p>To start a REPL run:</p><pre><code>lein repl
</code></pre><p>This will also download and install all dependencies that are given in the project.clj.</p><p>Now we can start and enter a simple <strong>hello world</strong> into the repl:</p><pre><code class="clojure">(println "Hello world!")
</code></pre><h2>Setting Up Your Editor</h2><h3>Sublime Text 2</h3><p>I started out, using Sublime Text 2. It's a good start. I can recommend installing <aside class="link-aside"><div class="link-aside--title">SublimeREPL</div><div class="link-aside--url"><a class="link-aside--url--link" href="https://github.com/wuub/SublimeREPL" target="_blank">https://github.com/wuub/SublimeREPL</a></div></aside><a href="https://github.com/wuub/SublimeREPL">SublimeREPL</a>. Clojure development uses the REPL extensively, so your editor should come with some kind of REPL integration.</p><p>I found SublimeREPL to be less stable as I would have liked. So I switched to vim.</p><p>One of the best editors for Clojure is Emacs, but I just can't get used to it :). All Emacs folks out there: please leave plugin recommendations in the comments, I will integrate them.</p><h3>vim</h3><p>As mentioned above I switched from Sublime to vim, because of its REPL integration via the <aside class="link-aside"><div class="link-aside--title">fireplace.vim</div><div class="link-aside--url"><a class="link-aside--url--link" href="https://github.com/tpope/vim-fireplace" target="_blank">https://github.com/tpope/vim-fireplace</a></div></aside><a href="https://github.com/tpope/vim-fireplace">fireplace.vim</a> plugin, proved to be more stable.</p><p>Once your setup is complete you will be able to send the complete file or single calls - under the cursor - to the REPL. Make sure this works. We will use it in the future of this tutorial. You can of course just continuously copy and paste the snippets to the REPL by hand. However that is very tedious and time consuming.</p><p>You want to use the REPL, because restating the JVM, just to execute one file, takes seconds, which makes for a very frustrating feedback cycle.</p><p>While you are at it you might also want to install  <aside class="link-aside"><div class="link-aside--title">rainbow_parentheses.vim</div><div class="link-aside--url"><a class="link-aside--url--link" href="https://github.com/kien/rainbow_parentheses.vim" target="_blank">https://github.com/kien/rainbow_parentheses.vim</a></div></aside><a href="https://github.com/kien/rainbow_parentheses.vim">rainbow_parentheses.vim</a>. It will highlight matching parenthesis in the same color, while giving each pair an individual color.</p><h2>Structuring Code</h2><h3>Files and Namespaces</h3><p>If you followed the tutorial and have created the <em>greenfeld_project</em> you will find a file called <code>src/greenfeld_project/core.clj</code>. This is the default starting point.</p><p>The first line of the file should look like this:</p><pre><code class="clojure">(ns greenfield-clojure.core)
</code></pre><p><code>ns</code> creates the new <em>namespace</em> <code>greenfeld-clojure</code>. Namespaces in Clojure have to respond to the file structure.</p><p>Given a namespace <code>greenfield-clojure.domain.user</code> it will look for a file in  <code>src/greenfeld_clojure/domain/user.clj</code>. Notice that it uses <code>_</code> for file names and <code>-</code> for the namespaces.</p><p>Lets create a new clj file:</p><pre><code>touch src/greenfield_clojure/util.clj
</code></pre><p>Following the naming schema we start a fitting namespace for that file by adding:</p><pre><code class="clojure">(ns greenfield-clojure.util)
</code></pre><p>All the following definitions will go into that namespace.</p><p>Now lets add a simple greeting function:</p><pre><code class="clojure">(ns greenfield-clojure.util)

(defn greet [name]
  (str "Welcome, " name "!"))
</code></pre><p>In the same namespace you can make a test call: <code>(greet "Jane")</code>.</p><p>If you have your REPL going just put the code below the function definition itself and send it to the REPL for evaluation. You can remove the code afterwards.</p><p>This way you can quickly sketch together some code and move and refactor later.</p><p>If you use the REPL via command line you can switch to this namespae (or any other valid namespace) by calling:</p><pre><code>(ns greenfield-clojure.util)
</code></pre><h3>Using Code from other Namespaces</h3><p>We don't just want to create namespaces, we want to use stuff that is located in other namespaces. We can do so by useing <code>use</code> and <code>require</code>.</p><h4>use</h4><p><code>use</code> will include all the vars (function definitions are just vars that point to functions) into the current namespace. This will NOT pull vars the used namespace itself includes via <code>use</code>. None the less: this pollutes you namespace and it gets harder to avoid clashes and find where functions are defined. However if you want to use clojure core namespaces - for example - it sometimes makes for nicer code.</p><p>Here we include <code>clojure.set</code> operations with the <code>use</code> function:</p><pre><code class="clojure">(use 'clojure.set)
(intersection #{1 2 3} #{3 4 5})
</code></pre><p>Notice that we need to quote the namespace, using a <code>'</code>.</p><p>This is useful when working in the REPL itself, but when you write files it's better to include this in the <code>ns</code> call directly useing <code>require</code> instead.</p><h4>require</h4><p>We have seen that <code>use</code>, while nice in some cases, pollutes our namespace.</p><p>Instead we use <code>require</code>. Let us require our util namespace from the core namespace:</p><pre><code class="clojure">(ns greenfield-clojure.core)
(require '(greenfield-clojure [util :as util]))
</code></pre><p>Now this is very cumbersome. Instead we can include everything we want to require directly in the <code>ns</code> call:</p><pre><code class="clojure">(ns greenfield-clojure.core
  (:require [greenfield-clojure.util :as util]))
</code></pre><p>With our utils library required, we can call its functions like this:</p><pre><code class="clojure">(util/greet "Xavier")
</code></pre><p>In clojure the <code>/</code> is used to reference vars from a different namespace.</p><p><strong>Update:</strong> Thanks to Pierre Mariani for pointing out that if you want to include every var from another namespace into the current namespace like <code>use</code> would you can and should use the following variant of require:</p><pre><code class="clojure">(ns greenfield-clojure.core
  (:require [clojure.set :refer [intersection]]))

(intersection #{1 2} #{2 3})
; =&gt; #{2}
</code></pre><p>Or if you want to refer everything from the namespace replace  <code>[intersection]</code> with <code>:all</code>.</p><pre><code class="clojure">(ns greenfield-clojure.core
  (:require [clojure.set :refer :all]))
</code></pre><p>I admit the hole requiring other namespaces is confusing. But I can also promise you that all the other stuff is much more thought thou and has more of a theme to it. Now if you are interested or still confused  <aside class="link-aside"><div class="link-aside--title">Colin Jones explains requiring code</div><div class="link-aside--url"><a class="link-aside--url--link" href="http://blog.8thlight.com/colin-jones/2010/12/05/clojure-libs-and-namespaces-require-use-import-and-ns.html" target="_blank">http://blog.8thlight.com/colin-jones/2010/12/05/clojure-libs-and-namespaces-require-use-import-and-ns.html</a></div></aside><a href="http://blog.8thlight.com/colin-jones/2010/12/05/clojure-libs-and-namespaces-require-use-import-and-ns.html">Colin Jones explains requiring code</a> in more detail.</p><h2>Executing from the Command Line</h2><p>Util now we only executed our code using a REPL, but at some point in time we will want to start our program from the command line.</p><p>There are two ways to do this:</p><ol><li>use leiningen</li><li>package everything up into one big jar file</li></ol><p>In any case our main namespace must contain a <code>-main</code> function that takes a variable number of arguments:</p><pre><code class="clojure">(defn -main[& args]
  (println (util/greet "Xavier")))
</code></pre><p>This will just always print the same greeting.</p><h3>Running with Leiningen</h3><p>Using leiningen we can call:</p><pre><code>lein run -m greenfield-clojure.core
</code></pre><p><code>-m</code> tells Leiningen which namespace to use for execution. The namespace must include a <code>-main</code> function. <em>Notice the <code>-</code> before the main</em>.</p><p>We can also specify the main namespace in our <code>project.clj</code>:</p><pre><code class="clojure">(defproject greenfield-clojure "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "Eclipse Public License"
            :url "http://www.eclipse.org/legal/epl-v10.html"}
  :main greenfield-clojure.core
  :dependencies [[org.clojure/clojure "1.4.0"]])
</code></pre><p>Now we can omit the <code>-m ...</code> part:</p><pre><code>lein run
</code></pre><h3>Creating an Uberjar</h3><p>We can use Leiningen to package everything up into one big jar that can be executed very simply.</p><p>For that we have to set the main namespace (same thing we did above):</p><pre><code class="clojure">(defproject greenfield-clojure "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "Eclipse Public License"
            :url "http://www.eclipse.org/legal/epl-v10.html"}
  :main greenfield-clojure.core
  :dependencies [[org.clojure/clojure "1.4.0"]])
</code></pre><p>But because this will be called directly, we have to tell clojure that it should compile the clojure code into a java class when creating the jar. To do this add a <code>(:gen-class)</code> argument to the <code>ns</code> call:</p><pre><code class="clojure">(ns greenfield-clojure.core
  (:require [greenfield-clojure.util :as util])
  (:gen-class))
</code></pre><p>This is call AOT (Ahead of Time Compilation). It's sufficient to do this for the main namespace only. You should be careful with this. In case implementations of core clojure functionality change your ATO compiled code might not be compatible without a renewed compilation.</p><p>A call to</p><pre><code>lein uberjar
</code></pre><p>will create a standalone jar in the <code>target</code> folder.</p><p>Run it via</p><pre><code>java -jar target/greenfield-clojure-0.1.0-SNAPSHOT-standalone.jar
</code></pre><h2>Summary</h2><p>We have done it!</p><p>In this tutorial we:</p><ol><li>setup and installed clojure from scratch</li><li>fired up a REPL for interactive development</li><li>configured our favorite editor (if it is Sublime or vim ;) )</li><li>learned how the file structure matches up to namespaces</li><li>how to create our own namespace</li><li>how to include code from other namespaces</li><li>we used leiningen to run our code from the command line</li><li>bundled everything up in one nice care-free jar that can be pushed around the computing world</li></ol><p>I hope this tutorial was helpful or interesting.</p><p>Any feedback is much appreciated.</p></div></article></div><script type="text/javascript">hljs.initHighlightingOnLoad();</script><footer class="page-footer"><nav><ul><li></li><li><a href="/" id="footer_nav_index">&#8613; index</a></li><li></li></ul></nav></footer></div></body></html>