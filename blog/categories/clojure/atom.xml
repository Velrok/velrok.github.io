<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: clojure | Mein(un)sinn]]></title>
  <link href="http://Velrok.github.io/blog/categories/clojure/atom.xml" rel="self"/>
  <link href="http://Velrok.github.io/"/>
  <updated>2014-12-27T20:57:49+00:00</updated>
  <id>http://Velrok.github.io/</id>
  <author>
    <name><![CDATA[velrok]]></name>
    <email><![CDATA[]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[deploying clojure apps on giant swarm (docker)]]></title>
    <link href="http://Velrok.github.io/blog/2014/12/21/deploying-clojure-apps-on-giant-swarm-docker/"/>
    <updated>2014-12-21T19:22:00+00:00</updated>
    <id>http://Velrok.github.io/blog/2014/12/21/deploying-clojure-apps-on-giant-swarm-docker</id>
    <content type="html"><![CDATA[<p><img style="float:left; height:190px" src="http://Velrok.github.io/images/giantswarm_logo_standard.png">
<img style="height:190px" src="http://Velrok.github.io/images/docker.png"></p>

<p>Recently I've been playing around with Clojure and <a href="https://www.docker.com/">docker</a>.
Docker provides your app with an isolated container on a Linux machine, sharing the
same system resources, while isolating them from the other containers.
This has the benefit of providing a separation between apps on a Linux host system,
which is much more light weigh than full blown VMs (Virtual Machines).</p>

<p>In this blog post I will describe the setup I used to deploy my pet project named
money-balance (a Clojure app) on <a href="https://giantswarm.io/">giantswarm.io</a>, a
docker host in Germany.
They are currently still in the alpha phase and looking for early adopters, but
so far everything was working flawlessly for me.
You can find them on <a href="https://gitter.im/giantswarm/users">gitter</a>.</p>

<!-- more -->


<h2>Overview</h2>

<p>My app uses the usual combination of <a href="https://github.com/weavejester/compojure">compojure</a>
and <a href="https://github.com/ring-clojure/ring">ring</a>.
Zaiste has a nice and short article which should set you up with a bare bone
Clojure web app skeleton. Feel free to ignore everything beyond the
backend section for now. <a href="http://zaiste.net/2014/02/web_applications_in_clojure_all_the_way_with_compojure_and_om/">Article</a>.</p>

<p>My deployment process consists of the following steps.</p>

<ol>
<li>build a stand alone jar <code>lein ring uberjar</code></li>
<li>increment application version (mirrored in the docker image version)</li>
<li>build a docker image with the necessary tag so that the image is stored in the
giantswarm repository instead of docker hub</li>
<li>push the image into the giantswarm repository</li>
<li>remove the old version of the application in giantswarm</li>
<li>create the app anew with the new version in giantswarm</li>
<li>start the new version</li>
</ol>


<p>A disclaimer, this is most likely not the most lean way of doing things.
For instance the whole versioning part of the deploy process could be
omitted, but I had a phase where I wasn't sure if the repository's latest
version of an image is the same as my local one.
According to the giantswarm support there is no way to find out if that true.
So my process states an explicit image version.</p>

<p>The deletion of the app and the recreation means that all services will be stooped
and all the data will be lost.
For my app this is not an issue, because I'm using a dedicated service to host
my database.
The swarm client has an update command, which is probably a better fit, and which
I will give a spin in the next weeks.</p>

<p>The rest of the article dives into the details and lists the source codes.</p>

<h2>the project.clj</h2>

<p>The <code>project.clj</code> is used by leiningen and declares all dependencies.</p>

<p>```clojure
(defproject money-balance "0.0.1"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "Eclipse Public License"</p>

<pre><code>        :url "http://www.eclipse.org/legal/epl-v10.html"}
</code></pre>

<p>  :dependencies [[org.clojure/clojure "1.6.0"]</p>

<pre><code>             [ring/ring-json "0.3.1"]
             [compojure "1.1.6"]
             [hiccup "1.0.5"]
             [cheshire "5.3.1"]
             [ring "1.2.2"]
             [ring-middleware-format "0.3.0" :exclusions [org.clojure/tools.reader]]
             [clj-time "0.6.0"]]
</code></pre>

<p>  :plugins [[lein-ring "0.8.10"]]
  :min-lein-version "2.0.0"
  :main money-balance.web.server
  :profiles {:production {:env {:production true}}</p>

<pre><code>         :dev {:dependencies [[midje "1.6.3"]]}
         :uberjar {:aot :all}}
</code></pre>

<p>  :uberjar-name "money-balance.jar"
  :ring {:handler money-balance.web.server/app})
```</p>

<p>The <code>plugins</code> section lists extensions to leiningen itself, for example <code>lein-ring</code>
is a plug-in which handles starting our app inside a jetty web server.
Plug-ins sometimes look inside the <code>defproject</code> for configuration.
For instance <code>:ring {:handler money-balance.web.server/app}</code> tell the ring plug-in
where to find our main handler.</p>

<p><strong>Note:</strong> The ring-plugin is not be be confused with the ring dependency.
The plug-in is a extention to leiningen, which makes it more convenient to start
a server and build a standalone uberjar, the ring dependency is a abstraction
that allows one to deal with requests and responses as Clojure maps instead of
java objects.</p>

<h2>the Dockerfile</h2>

<p>For a introduction to docker head to <a href="https://www.docker.com/">https://www.docker.com/</a>.</p>

<p>```ruby
FROM java:7
MAINTAINER Velrok</p>

<p>RUN mkdir -p /opt/money-balance
ADD ./target/money-balance.jar /opt/money-balance/money-balance.jar
ADD ./VERSION /opt/money-balance/VERSION
ADD ./public /opt/money-balance/public</p>

<p>WORKDIR /opt/money-balance</p>

<p>EXPOSE 3000
ENV APP_ENV production</p>

<p>ENTRYPOINT java -jar money-balance.jar
```</p>

<p>While docker hub provides a <a href="https://registry.hub.docker.com/u/library/clojure/">Clojure image</a>
I found the plain <a href="https://registry.hub.docker.com/_/java/">java base image</a> to be a better
fit for the job.
It is simply easier to build a standalone jar on your machine and copy it into a
plain java image.
Having said that, the Clojure image worked without errors for me. If you prefer
to have the lein command at hand on the machine you may as well use that one.</p>

<p><code>ADD ./target/money-balance.jar /opt/money-balance/money-balance.jar</code> copies a local build into the docker image.
<code>EXPOSE 3000</code> takes care of exposing the webserver port to the host system, which is
nessesary to allow http connections into the container.
<code>ENTRYPOINT java -jar money-balance.jar</code> tells docker, that this command should be run
when the image is started. Thus when a new container comes up it will
autostart the standalone jar file.</p>

<p><strong>Side-note:</strong>
 - how I tryied to make the Clojure image work</p>

<h2>the build.sh</h2>

<p>The build script is concerned with building a docker image, with the application
in it and pushing the image into the swarm registry so it's available for deployment.</p>

<p>```bash</p>

<h1>!/bin/bash</h1>

<p>set -e</p>

<p>lein ring uberjar
./increment_version.rb $@
docker build --rm=true -t registry.giantswarm.io/velrok/money-balance:$(cat ./VERSION) .
docker push registry.giantswarm.io/velrok/money-balance:$(cat ./VERSION)
```</p>

<p><code>lein ring uberjar</code> creates a standalone jar, which starts the app on port 3000.
<code>./increment_version.rb $@</code> is a small script, that increaments the version string
in my <code>VERSION</code> file.
<code>docker build --rm=true -t registry.giantswarm.io/velrok/money-balance:$(cat ./VERSION) .</code>
instructs docker to build a new image, taged with the giant swarm repository and
my explicit latest version from the <code>VERSION</code> file.
<code>docker push registry.giantswarm.io/velrok/money-balance:$(cat ./VERSION)</code>
pushes the image to the giant swarm docker repository, so they can start
containers with the latest version.</p>

<p>I found it reassuring to have thouse commands in a simple <code>build.sh</code> just to
make sure I never forget to tag my image with the correct repository, because
docker will publish your image to dockerhub by default.</p>

<p>If you don't care about explicit verisons just use <code>latest</code> and don't maintain
a <code>VERSION</code> file.
<code>docker build --rm=true -t registry.giantswarm.io/velrok/money-balance:latest .</code></p>

<h2>deploying to giant swarm</h2>

<p>In order to deploy to giantswarm you will need an account and the command
line client. Follow this <a href="file:///Users/waldemarschwan/webpages/docs.giantswarm.io/installation/cheatsheet/index.html_">setup guide</a>
to get started.</p>

<p>You describe our application in terms of services and components in a <code>swarm.json</code>
file.
Here is mine:</p>

<p>```json
{
  "app_name": "money-balance",
  "services": [</p>

<pre><code>{
  "service_name": "money-balance-service",
  "components": [
    {
      "component_name": "money-balance",
      "image": "registry.giantswarm.io/velrok/money-balance:$version",
      "ports": [ "3000/tcp" ],
      "domains": { "money-balance.velrok.gigantic.io": "3000" },
      "env" : [
        "APP_ENV=production",
        "MONEY_BALANCE_DATABASE_URI=postgres://xxx"
      ]          
    }
  ]
}
</code></pre>

<p>  ]
}
<code>``
It declares an application named</code>money-balance<code>
</code>"app_name": "money-balance"<code>, which has only one service</code>money-balance-service<code>
with only one component.
</code>"image": "registry.giantswarm.io/velrok/money-balance:$version"<code>declares that
our container should use our money-balance images, which has been build and
pushed in the</code>build.sh<code>script.
</code>$version<code>is a swarm client variable, which can be set later, when we actually
call the swarm client to start our app.
It enables us to explicitly name the latest version, without the need to adjust
the</code>swarm.json<code>file.
</code>"domains": { "money-balance.velrok.gigantic.io": "3000" }<code>declares that we
want our app to be reachable from the internet under the domain name
</code>money-balance.velrok.gigantic.io<code>and that our app excepts http requests on
port 3000.
Since I'm using a different service for my database, the actual connection string
for the production database is set via the environment variable
</code>MONEY_BALANCE_DATABASE_URI`.</p>

<p>We can start up the app manually now, calling <code>swarm create swarm.json</code> and then
<code>swarm start money-balance</code>.</p>

<h2>the deploy.sh</h2>

<p>The deploy script is concerned about stooping the old version of the app
on the host and starting up the latest version instead.</p>

<p><code>bash
swarm delete -y money-balance
swarm create --var=version=$(cat ./VERSION) swarm.json
sleep 1
swarm start money-balance
sleep 1
swarm status money-balance
</code></p>

<p><code>swarm delete -y money-balance</code> deletes the old version of the app from
giant swarm. This is rather drastic, since this will stop all services
and remove all containers, loosing all the data that has been stored on any
container.
<code>swarm update</code> presents a more elegant alternative, which I'm still to explore
in the next days.
<code>swarm create --var=version=$(cat ./VERSION) swarm.json</code> recreates the app with
the latest version specified in the VERSION file.</p>

<p><code>swarm start money-balance</code> starts up the application and
<code>swarm status money-balance</code> returns the status of the app.</p>

<h2>conclusion</h2>

<p>I found the <a href="https://registry.hub.docker.com/_/java/tags/manage/">plain java image</a>
to work best as the base image for my Clojure app by compiling it into a single
jar file.
If you prefer to have the lein command available on the docker container
you can just use the <a href="https://registry.hub.docker.com/u/library/clojure/">Clojure image</a>
as the base image.
Just be aware, that it will have to download all the project dependencies
the first time you start it.</p>

<p>Even so <a href="https://giantswarm.io">giantswarm</a> is still in alpha it is working well
so far. Definatly worth a shot if you are trying to get more experience with
docker and want a free (for now) hoster.</p>

<p>My current deployment process is lacking any rollback features as well as any
migrations strategy.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clojure Getting Started: Setting Up]]></title>
    <link href="http://Velrok.github.io/blog/2013/07/17/clojure-ggetting-started/"/>
    <updated>2013-07-17T10:54:00+01:00</updated>
    <id>http://Velrok.github.io/blog/2013/07/17/clojure-ggetting-started</id>
    <content type="html"><![CDATA[<h2>Setting Up a Project</h2>

<p>Clojure runs on the JVM so you need a recent
<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">JDK</a>
version installed
(Java 6 or newer should do).</p>

<p>To create a new Clojure project we use <a href="https://github.com/technomancy/leiningen">Leiningen</a>.
On Mac OS it's just a</p>

<p><code>
brew install leiningen
</code>
away.</p>

<p>This will install Leiningen 2.
Version 2 breaks compatibility with the old plugin system, but most projects
that supply Leiningen have a description how to add them to your project.clj
for each version.
However if you start a new project, always go with Leiningen 2.</p>

<p>To create our getting started project (we will name it greenfield-clojure) run:
<code>
lein new greenfield-clojure
</code></p>

<p>This will create a new folder. For the rest of this writing all file paths will
be relative to this folder.</p>

<p>You should see a <code>project.clj</code> file looking something like this</p>

<p>```clojure
(defproject greenfield-clojure "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "Eclipse Public License"</p>

<pre><code>        :url "http://www.eclipse.org/legal/epl-v10.html"}
</code></pre>

<p>  :dependencies [[org.clojure/clojure "1.5.1"]])
```
As you can see Clojure itself is defined as a dependency.
As of this writing the latest version is 1.5.1 .</p>

<p>Now run
<code>bash
lein deps
</code>
which will download and install all specified dependencies.</p>

<p>During this project we will add additional dependencies to this project.
<a href="https://clojars.org/clj-http">CloJars</a> is a repository for Clojure libaries.
There you can find a lot of interesting stuff.
You can also include Java dependencies from <a href="http://search.maven.org/">Maven Central</a>.
Please consult the Leiningen <a href="https://github.com/technomancy/leiningen/blob/stable/sample.project.clj">sample.project.clj</a>
for further information.</p>

<!-- more -->


<h2>The REPL</h2>

<p>The REPL is a interactive environment where you can run Clojure code, in the
context of your project.</p>

<p>To start a REPL run:
<code>
lein repl
</code>
This will also download and install all dependencies that are given in the
project.clj.</p>

<p>Now we can start and enter a simple <strong>hello world</strong> into the repl:</p>

<p><code>clojure
(println "Hello world!")
</code></p>

<h2>Setting Up Your Editor</h2>

<h3>Sublime Text 2</h3>

<p>I started out, using Sublime Text 2.
It's a good start. I can recommend installing <a href="https://github.com/wuub/SublimeREPL">SublimeREPL</a>.
Clojure development uses the REPL extensively, so your editor should
come with some kind of REPL integration.</p>

<p>I found SublimeREPL to be less stable as I would have liked.
So I switched to vim.</p>

<p>One of the best editors for Clojure is Emacs, but I just can't get
used to it :). All Emacs folks out there: please leave plugin recommendations
in the comments, I will integrate them.</p>

<h3>vim</h3>

<p>As mentioned above I switched from Sublime to vim, because of its better REPL
integration
via the <a href="https://github.com/tpope/vim-fireplace">fireplace.vim</a> plugin,
proved to be more stable.</p>

<p>Once your setup is complete you will be able to send the complete file or
single calls - under the cursor - to the REPL.
Make sure this works. We will use it in the future of this tutorial.
You can of course just continuously copy and paste the snippets to the REPL by
hand. However that is very tedious and time consuming.</p>

<p>You want to use the REPL, because restating the JVM, just to execute one file,
takes seconds, which makes for a very frustrating feedback cycle.</p>

<p>While you are at it you might also want to install
<a href="https://github.com/kien/rainbow_parentheses.vim">rainbow_parentheses.vim</a>.
It will highlight matching parenthesis in the same color, while giving each pair
an individual color.</p>

<h2>Structuring Code</h2>

<h3>Files and Namespaces</h3>

<p>If you followed the tutorial and have created the <em>greenfeld_project</em> you will
find a file called <code>src/greenfeld_project/core.clj</code>.
This is the default starting point.</p>

<p>The first line of the file should look like this:</p>

<p><code>clojure
(ns greenfield-clojure.core)
</code></p>

<p><code>ns</code> creates the new <em>namespace</em> <code>greenfeld-clojure</code>.
Namespaces in Clojure have to respond to the file structure.</p>

<p>Given a namespace <code>greenfield-clojure.domain.user</code> it will look for a file in
<code>src/greenfeld_clojure/domain/user.clj</code>.
Notice that it uses <code>_</code> for file names and <code>-</code> for the namespaces.</p>

<p>Lets create a new clj file:</p>

<p><code>
touch src/greenfield_clojure/util.clj
</code></p>

<p>Following the naming schema we start a fitting namespace for that file by
adding:</p>

<p><code>clojure
(ns greenfield-clojure.util)
</code></p>

<p>All the following definitions will go into that namespace.</p>

<p>Now lets add a simple greeting function:</p>

<p>```clojure
(ns greenfield-clojure.util)</p>

<p>(defn greet [name]
  (str "Welcome, " name "!"))
```</p>

<p>In the same namespace you can make a test call: <code>(greet "Jane")</code>.</p>

<p>If you have your REPL going just put the code below the function definition
itself and send it to the REPL for evaluation.
You can remove the code afterwards.</p>

<p>This way you can quickly sketch together some code and move and refactor later.</p>

<p>If you use the REPL via command line you can switch to this namespae (or any other valid
namespace) by calling:</p>

<p><code>
(ns greenfield-clojure.util)
</code></p>

<h3>Using Code from other Namespaces</h3>

<p>We don't just want to create namespaces, we want to use stuff that is
located in other namespaces. We can do so by useing <code>use</code> and <code>require</code>.</p>

<h4>use</h4>

<p><code>use</code> will include all the vars (function definitions are just vars that point
to functions) into the current namespace.
This will NOT pull vars the used namespace itself includes via <code>use</code>.
None the less: this pollutes you namespace and it gets harder to avoid clashes
and find where functions are defined.
However if you want to use clojure core namespaces - for example - it sometimes
makes for nicer code.</p>

<p>Here we include <code>clojure.set</code> operations with the <code>use</code> function:</p>

<p><code>clojure
(use 'clojure.set)
(intersection #{1 2 3} #{3 4 5})
</code></p>

<p>Notice that we need to quote the namespace, using a <code>'</code>.</p>

<p>This is useful when working in the REPL itself, but when you write files it's
better to include this in the <code>ns</code> call directly useing <code>require</code> instead.</p>

<h4>require</h4>

<p>We have seen that <code>use</code>, while nice in some cases, pollutes our namespace.</p>

<p>Instead we use <code>require</code>. Let us require our util namespace from the core
namespace:</p>

<p><code>clojure
(ns greenfield-clojure.core)
(require '(greenfield-clojure [util :as util]))
</code></p>

<p>Now this is very cumbersome. Instead we can include everything we want to
require directly in the <code>ns</code> call:</p>

<p><code>clojure
(ns greenfield-clojure.core
  (:require [greenfield-clojure.util :as util]))
</code></p>

<p>With our utils library required, we can call its functions like this:</p>

<p><code>clojure
(util/greet "Xavier")
</code></p>

<p>In clojure the <code>/</code> is used to reference vars from a different namespace.</p>

<p><strong>Update:</strong>
Thanks to Pierre Mariani for pointing out that if you want to include
every var from another namespace into the current namespace like <code>use</code> would
you can and should use the following variant of require:</p>

<p>```clojure
(ns greenfield-clojure.core
  (:require [clojure.set :refer [intersection]]))</p>

<p>(intersection #{1 2} #{2 3})
; => #{2}
```</p>

<p>Or if you want to refer everything from the namespace replace
<code>[intersection]</code> with <code>:all</code>.</p>

<p><code>clojure
(ns greenfield-clojure.core
  (:require [clojure.set :refer :all]))
</code></p>

<p>I admit the hole requiring other namespaces is confusing. But I can also
promise you that all the other stuff is much more thought thou and has more
of a theme to it.
Now if you are interested or still confused
<a href="http://blog.8thlight.com/colin-jones/2010/12/05/clojure-libs-and-namespaces-require-use-import-and-ns.html">Colin Jones explains requiring code</a>
in more detail.</p>

<h2>Executing from the Command Line</h2>

<p>Util now we only executed our code using a REPL, but at some point in time
we will want to start our program from the command line.</p>

<p>There are two ways to do this:</p>

<ol>
<li>use leiningen</li>
<li>package everything up into one big jar file</li>
</ol>


<p>In any case our main namespace must contain a <code>-main</code> function that takes
a variable number of arguments:</p>

<p><code>clojure
(defn -main[&amp; args]
  (println (util/greet "Xavier")))
</code></p>

<p>This will just always print the same greeting.</p>

<h3>Running with Leiningen</h3>

<p>Using leiningen we can call:</p>

<p><code>
lein run -m greenfield-clojure.core
</code></p>

<p><code>-m</code> tells Leiningen which namespace to use for execution.
The namespace must include a <code>-main</code> function.
<em>Notice the <code>-</code> before the main</em>.</p>

<p>We can also specify the main namespace in our <code>project.clj</code>:</p>

<p>```clojure
(defproject greenfield-clojure "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "Eclipse Public License"</p>

<pre><code>        :url "http://www.eclipse.org/legal/epl-v10.html"}
</code></pre>

<p>  :main greenfield-clojure.core
  :dependencies [[org.clojure/clojure "1.4.0"]])
```</p>

<p>Now we can omit the <code>-m ...</code> part:</p>

<p><code>
lein run
</code></p>

<h3>Creating an Uberjar</h3>

<p>We can use Leiningen to package everything up into one big jar that can be
executed very simply.</p>

<p>For that we have to set the main namespace (same thing we did above):</p>

<p>```clojure
(defproject greenfield-clojure "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "Eclipse Public License"</p>

<pre><code>        :url "http://www.eclipse.org/legal/epl-v10.html"}
</code></pre>

<p>  :main greenfield-clojure.core
  :dependencies [[org.clojure/clojure "1.4.0"]])
```</p>

<p>But because this will be called directly, we have to tell clojure that it should
compile the clojure code into a java class when creating the jar.
To do this add a <code>(:gen-class)</code> argument to the <code>ns</code> call:</p>

<p><code>clojure
(ns greenfield-clojure.core
  (:require [greenfield-clojure.util :as util])
  (:gen-class))
</code></p>

<p>This is call AOT (Ahead of Time Compilation).
It's sufficient to do this for the main namespace only.
You should be careful with this. In case implementations of core clojure
functionality change your ATO compiled code might not be compatible without a
renewed compilation.</p>

<p>A call to
<code>
lein uberjar
</code>
will create a standalone jar in the <code>target</code> folder.</p>

<p>Run it via
<code>
java -jar target/greenfield-clojure-0.1.0-SNAPSHOT-standalone.jar
</code></p>

<h2>Summary</h2>

<p>We have done it!</p>

<p>In this tutorial we:</p>

<ol>
<li>setup and installed clojure from scratch</li>
<li>fired up a REPL for interactive development</li>
<li>configured our favorite editor (if it is Sublime or vim ;) )</li>
<li>learned how the file structure matches up to namespaces</li>
<li>how to create our own namespace</li>
<li>how to include code from other namespaces</li>
<li>we used leiningen to run our code from the command line</li>
<li>bundled everything up in one nice care-free jar that can be pushed around the computing world</li>
</ol>


<p>I hope this tutorial was helpful or interesting.</p>

<p>Any feedback is much appreciated.</p>
]]></content>
  </entry>
  
</feed>
